(** ** Typing, Context Morphism Lemmas, and Preservation *)
(* ctx as total maps*)
From CARVe Require Import core fintype stlc step.
Import ScopedNotations.

From Coq Require Import List.
Import List.ListNotations.
From Coq Require Import Unicode.Utf8.
From Coq Require Import Lia.
From Hammer Require Import Hammer.
Require Import Coq.Program.Equality.
Require Import Coq.Logic.JMeq.

Require Import VST.msl.sepalg.
Require Import VST.msl.functors.
From CARVe.contexts Require Import total_fun.
From CARVe.algebras Require Import purely_linear.



Declare Custom Entry stlc.
Notation "<{ e }>" := e (e custom stlc at level 99).
Notation "( x )" := x (in custom stlc, x at level 99).
Notation "x" := x (in custom stlc at level 0, x constr at level 0).
Notation "S -o T" := (Fun  S T) (in custom stlc at level 50, right associativity).
Notation "x ^ y" := (Core.app x y) (in custom stlc at level 1, left associativity).
Notation "/\ T e " :=
  (lam T e) (in custom stlc at level 90,
        e custom stlc at level 99,
        left associativity).
        
 
Definition tenv n := tfctx (fin n) ty mult.

Parameter upd : forall N, tenv N → ch N → ch N → sType → sType → mult → mult → tenv N -> Prop .

Definition shift_tenv {n : nat} (T : sType) (m : mult) (e : tenv n) : tenv n.+1 
  := scons  (T,m) e.


Inductive has_type {n} (Δ : tenv n):   tm n -> ty -> Prop :=

   | t_Var: forall (Δ': tenv n) (T : ty)  (fn : fin n),
  
  updn   Δ fn fn  T T one zero Δ'  -> 
     @exh _ _ mult hal Δ' -> 
    has_type Δ (var_tm fn) T
 | t_Abs: forall (T1 T2: ty)  e1,
    has_type (scons (T2,one)  Δ) e1 T1 ->
    has_type Δ (lam T2 e1) (Fun  T2 T1)
| t_App: forall ( Δ1 Δ2 :tenv n) (T1 T2 : ty)    (e1 e2 : tm n) ,
    has_type Δ1 e1 (Fun T2 T1) ->
    has_type Δ2 e2 T2 -> join Δ1 Δ2 Δ
    -> has_type Δ (Core.app e1 e2) T1.

Notation "Δ '|-' e ':' T" := (has_type Δ e T) (at level 40).     

Definition emptyT  := fun x : fin 0 => (Base,zero).
(*
Definition emptyT : tenv 0:= fun x => match x  return (ty * mult)with end.
*)
Lemma join_emptyT: forall Δ1 Δ2, join Δ1 Δ2 emptyT -> Δ1 = emptyT /\
Δ2 = emptyT. 
intros. 
Admitted.


Lemma canonical_forms_fun : forall    (M : tm 0)  T1 T2,
  has_type (emptyT ) M (Fun T1  T2) ->
  value M ->
  exists N U, M = (lam U N).
Proof.
sauto lq: on .
Qed.    

Lemma progress (M : tm 0)  : forall T,
  has_type emptyT M  T -> value M \/ exists M', step M M'.  
  Proof.
  dependent induction M;
  intros.
   - (* var *)
    simpl in H. sfirstorder.
  - (* app *)
    right.
    inversion H; clear H; subst.
    apply join_emptyT in H5; sintuition.
  
 
  specialize (IHM1 M1 eq_refl JMeq_refl <{ T2 -o T }>). 
    destruct (IHM1 H2).
      + (* t1 is a value *)
        apply canonical_forms_fun in H2; [|assumption].
        destruct H2 as [x [t H2]]; subst.
        specialize (IHM2 M2 eq_refl JMeq_refl T2). 
        destruct (IHM2 H3).
        * (* ... and t2 is a value *) eauto.
        * (* ... and t2 can step *) destruct H0 as [t' H0]. eauto.
      + (* t1 can step *)
        destruct H as [t' H]. eauto.
  - (*lam *) sfirstorder. 
   
Qed.

    
(*
Lemma typing_inst n k (Gamma: tenv) (Delta: tenv) (sigma: fin n -> tm k) (M: tm n) T :
  (forall x, Delta |- sigma x : Gamma x) -> Gamma |- M : T ->  Delta |- (M[sigma]) : T.
*)
Lemma preservation (n : nat) (Gamma: tenv n) (M : tm n) T :
  has_type Gamma M  T -> forall M', step M M' -> has_type Gamma  M'  T.
Proof.
  induction 1; intros M' H'; cbn.
  - inv H'.
  - inv H'. econstructor. now apply IHhas_type.
  - inv H'.
    + admit. (*inv H. eapply typing_inst; try eassumption.
      auto_case. constructor.*)
    + eapply t_App; eauto.
    + eapply t_App; eauto.
    Admitted.

(*    

(** Typing predicate 

(** A context *)
Definition ctx n := fin n -> ty.

Inductive has_type {n} (Gamma : ctx n) : tm n -> ty -> Prop :=
| ty_var_tm (x : fin n) :
    has_type Gamma (var_tm x) (Gamma x)
| ty_abs (S1 S2 : ty) (M : tm (S n)) :
    @has_type (S n) (S1 .: Gamma) M S2 ->
    has_type Gamma (lam S1 M) (Fun S1 S2)
| ty_app (T S : ty) (M N : tm n) :
    has_type Gamma M (Fun T S) ->
    has_type Gamma N T ->
    has_type Gamma (app M N) S.
Notation "Gamma |- M : T" := (has_type Gamma M T) (at level 20, M at level 99).
*)

(** Context renaming *)
Definition ltc {k k'} (Gamma: ctx k) (Delta: ctx k') rho := forall x, Delta (rho x) = Gamma x.

(** Context renaming lemma *)
Lemma typing_ren n k (Gamma: ctx n) (Delta: ctx k) (rho: fin n -> fin k) (M: tm n) T :
  ltc Gamma Delta rho  -> Gamma |- M : T ->  Delta |- (M⟨rho⟩) : T.
Proof.
  intros C H. revert k Delta rho C. induction H; intros; cbn; eauto.
  - unfold ltc in C. rewrite <- C. constructor.
  - constructor. apply IHhas_type. asimpl. unfold ltc. auto_case.
  - econstructor; eauto.
Qed.

Lemma typing_inst n k (Gamma: ctx n) (Delta: ctx k) (sigma: fin n -> tm k) (M: tm n) T :
  (forall x, Delta |- sigma x : Gamma x) -> Gamma |- M : T ->  Delta |- (M[sigma]) : T.
Proof.
  intros C H. revert k Delta sigma C. induction H; intros; asimpl; eauto.
  - constructor. apply IHhas_type. auto_case.
    + eapply typing_ren; eauto. intros. unfold ltc. now asimpl.
    + constructor.
  - econstructor; eauto.
Qed.

Qed.
*)
