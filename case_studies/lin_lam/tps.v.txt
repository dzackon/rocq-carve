(** ** List based, not dependent *)

From CARVe Require Import core fintype  stlc step.
Import ScopedNotations.

From Coq Require Import List.
Import List.ListNotations.
From Coq Require Import Unicode.Utf8.
From Coq Require Import Lia.
From Hammer Require Import Hammer.
Require Import Coq.Program.Equality.

Require Import VST.msl.sepalg.
Require Import VST.msl.functors.
From CARVe.contexts Require Import list.
From CARVe.algebras Require Import purely_linear.



Declare Custom Entry stlc.
Notation "<{ e }>" := e (e custom stlc at level 99).
Notation "( x )" := x (in custom stlc, x at level 99).
Notation "x" := x (in custom stlc at level 0, x constr at level 0).
Notation "S -o T" := (Fun  S T) (in custom stlc at level 50, right associativity).
Notation "x ^ y" := (Core.app x y) (in custom stlc at level 1, left associativity).
Notation "/\ T e " :=
  (lam T e) (in custom stlc at level 90,
        e custom stlc at level 99,
        left associativity).
        
        
(**
Definition ctx n := fin n -> ty.
*)


Definition tenv := lctx ty mult.

(* not used *)
Fixpoint fin_to_nat {n : nat} (x : fin n) : nat :=
  match n, x with
  | 0, x => match x with end  (* impossible case *)
  | S m, None => 0
  | S m, Some y => S (fin_to_nat y)
  end.
         
Inductive has_type {n}: tenv -> tm n -> ty -> Prop :=
(* | oft/var : upd Î” n _ _ A A ðŸ™ ðŸ˜ Î”' â†’ exh Î”' â†’ oft Î” (var n) A*)
| t_Var: forall (Î” Î”': tenv) (T : ty)  (fn : fin n),
    updn ty  Î” (n) T T one zero Î”' ->  
    exh hal Î”' ->  
    has_type Î” (var_tm fn) T
| t_Abs: forall Î” (T1 T2: ty)  e1,
    has_type ((T2,one):: Î”) e1 T1 ->
    has_type Î” (lam T2 e1) (Fun  T2 T1)
| t_App: forall (Î” Î”1 Î”2 :tenv) (T1 T2 : ty)    (e1 e2 : tm n) ,
    has_type Î”1 e1 (Fun T2 T1) ->
    has_type Î”2 e2 T2 -> join Î”1 Î”2 Î”
    -> has_type Î” (Core.app e1 e2) T1.

Notation "Î” '|-' e ':' T" := (has_type Î” e T) (at level 40).     

(* should we state it for tm 0 ? I know, it's un upper bound, still. *)

(* just checking*) 
Check (lam Base (var_tm var_zero) : tm 0).

Check (lam Base (var_tm var_zero) : tm 1).

Lemma canonical_forms_fun : forall n (M : tm n) T1 T2,
  has_type nil M (Fun T1  T2) ->
  value M ->
  exists N U, M = (lam U N).
Proof.
sauto lq: on .
Qed.    


Lemma progress0   (M : tm 0)  : forall T,
  has_type nil M  T -> value M \/ exists (M' : tm 0), step M M'.  
  Proof.
    induction M; intros. 
  - (* var *)
    inv H.  inv H.
  - (* app *)
    right.
    inversion H; clear H; subst.
     inversion H6; clear H6; subst.
      destruct (IHM1 _ H2).
      + (* t1 is a value *)
        apply canonical_forms_fun in H2; [|assumption].
        destruct H2 as [x [t H2]]; subst.
        destruct (IHM2 _ H4).
        * (* ... and t2 is a value *) eauto.
        * (* ... and t2 can step *) destruct H0 as [t' H0]. eauto.
      + (* t1 can step *)
        destruct H as [t' H]. eauto.
  - (*lam *) sfirstorder. 
Qed.

  (** to port development in ../Chapter9/preservation.v
  (*
Definition ltc {k k'} (Gamma: ctx k) (Delta: ctx k') rho := forall x, Delta (rho x) = Gamma x.
*)
    
(*
Lemma typing_inst n k (Gamma: tenv) (Delta: tenv) (sigma: fin n -> tm k) (M: tm n) T :
  (forall x, Delta |- sigma x : Gamma x) -> Gamma |- M : T ->  Delta |- (M[sigma]) : T.
*)
Lemma preservation (n : nat) (Gamma: tenv) (M : tm n) T :
  has_type Gamma M  T -> forall M', step M M' -> has_type Gamma  M'  T.
Proof.
  induction 1; intros M' H'; cbn.
  - inv H'.
  - inv H'. econstructor. now apply IHhas_type.
  - inv H'.
    + admit. (*inv H. eapply typing_inst; try eassumption.
      auto_case. constructor.*)
    + eapply t_App; eauto.
    + eapply t_App; eauto.
    Admitted.
