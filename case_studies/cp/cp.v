(* ======================================================= *)
(* CP                                                      *)
(* ======================================================= *)

(** A preliminary mechanization of a small fragment of CP (ðŸ™/âŠ¥/cut).
    This is sufficient to illustrate CARVe's ability to handle list-based
    contexts of linear resources: the cut rule requires us to merge / split
    a context in two.

    The mechanization encodes syntax, typing rules, and proves
    progress assuming exchange (in progress.v). *)

From Stdlib Require Import List Program.Equality Sets.Permut Sorting.Permutation.
From Hammer Require Import Tactics.
From VST Require Import sepalg.
From CARVe Require Import list linear.

(* Definitions and basic properties *)

(** Processes *)
Inductive process : Type :=
| close : process
| wait  : process -> process
| cut   : process -> process -> process.

(** Type system *)
Inductive ty : Type :=
| ty_one : ty
| ty_bot : ty.

Notation "ðŸ™" := ty_one.
Notation "âŠ¥" := ty_bot.

Definition dual (A : ty) : ty :=
  match A with
  | ðŸ™ => âŠ¥
  | âŠ¥ => ðŸ™
  end.

Lemma dual_involutive : forall A, dual (dual A) = A.
Proof. induction A; strivial. Qed.

(* We use list-based contexts where mult is CARVe's linear algebra. *)
Definition ctx := @lctx ty mult.

(* Typing rules *)

Inductive has_type : process -> ctx -> Prop :=
| has_close : forall {G G' n},
    upd_rel G n (ty_one, one) (ty_one, zero) G' ->
    exh G' ->
    has_type close G

| has_wait : forall {G G' : ctx} {n} {P : process},
    upd_rel G n (âŠ¥, one) (âŠ¥, zero) G' ->
    has_type P G' ->
    has_type (wait P) G

| has_cut : forall {G G1 G2 : ctx} {A : ty} {P1 P2 : process},
    join G1 G2 G ->
    has_type P1 ((A, one) :: G1) ->
    has_type P2 ((dual A, one) :: G2) ->
    has_type (cut P1 P2) G.

(* Congruences *)

(** Congruence generated by associativity and commutativity of cut *)
Inductive cong : process -> process -> Prop :=
| cut_comm   : forall {P Q}, cong (cut P Q) (cut Q P)
| cut_assoc  : forall {P Q R}, cong (cut (cut P Q) R) (cut P (cut Q R))
| cong_left  : forall {P Q R}, cong P Q -> cong (cut P R) (cut Q R)
| cong_right : forall {P Q R}, cong Q R -> cong (cut P Q) (cut P R)
| cong_refl  : forall {P}, cong P P
| cong_trans : forall {P Q R}, cong P Q -> cong Q R -> cong P R
| cong_sym   : forall {P Q}, cong P Q -> cong Q P.

Notation "P â‰¡ Q" := (cong P Q) (at level 100).

(* Process reduction *)

Inductive reduction : process -> process -> Prop :=
| beta_one_bot   : forall {P}, reduction (cut close (wait P)) P
| red_cut_cong   : forall {P P' Q}, reduction P P' -> reduction (cut P Q) (cut P' Q)
| red_cong       : forall {P Q R S}, cong P Q -> reduction Q R -> cong R S -> reduction P S
| kappa_cut_wait : forall {P Q}, reduction (cut (wait P) Q) (wait (cut P Q)).